---
title: 'Multi-signature transactions in a Peer-to-Peer World'
description: 'The quest to decentralize multi-signature coordination'
image:
  src: /img/blog/musig2-p2p.jpg
authors:
  - name: Matthew Urgero
    to: https://x.com/mcp011011
    avatar:
      src: /img/matthew_urgero.jpeg
date: 2025-11-13
badge:
  label: Technical Deep Dive
---

Multi-signature wallets are deceptively simple in theory. Two friends wanting to co-sign transactions, a DAO treasury requiring council approval, a business with multiple stakeholders—the concept is straightforward. The challenging part isn't the cryptography or the on-chain mechanics. It's the coordination.

How do participants discover a pending signing session? Who broadcasts the final transaction? What happens when Alice goes offline mid-signature, Bob's coordinator crashes, and Charlie can't remember if he already sent his partial signature? Traditional solutions wave their hands at these questions: "use a trusted server" or "coordinate out-of-band" or "just run your own infrastructure."

These aren't solutions. They're acknowledgments that the problem is hard, so we should just centralize it away or burden users with operational complexity. But peer-to-peer coordination is solvable. It requires thinking carefully about distributed systems, honest engineering, and a willingness to build infrastructure that makes the hard parts invisible.

This article describes how we built truly decentralized multi-signature coordination for Lotus, and why it matters for the broader cryptocurrency ecosystem.

## What is MuSig2 and Why Does It Matter?

MuSig2 is a multi-signature protocol for Schnorr signatures. Multiple parties collaborate to produce a single, aggregated signature that's cryptographically indistinguishable from a signature made by one person. A three-person treasury spending funds looks identical on-chain to someone buying coffee.

The privacy and efficiency gains are substantial. Traditional P2SH multi-signature for three participants requires 99 bytes of public keys and 210 bytes of signatures—309 bytes total. MuSig2 with Taproot uses 33 bytes for the public key and 64 bytes for the signature—97 bytes, an 83% reduction. More importantly, the transaction provides no information about how many parties were involved or what the signing threshold was.

The security properties are rigorous. MuSig2 prevents rogue key attacks through key aggregation coefficients derived from all participant keys. It prevents nonce reuse attacks (which would leak private keys) through careful session management and deterministic nonce generation. The scheme is provably secure under the [discrete logarithm assumption](https://en.wikipedia.org/wiki/Discrete_logarithm), the same assumption securing single-signature Schnorr and ECDSA.

When combined with Taproot, MuSig2 enables sophisticated on-chain behaviors that look like basic payments:

- **Payment channels** with complex dispute resolution—Alice and Bob's Lightning-style channel appears as a standard address
- **DAO treasuries** requiring 7-of-10 council approval—the entire multi-sig setup is invisible
- **Vaults with time locks**—funds locked for six months unless multiple parties agree to early release
- **Conditional spending**—"pay Bob if these conditions are met, otherwise refund Alice"

All of these appear on-chain as simple, single-signature transactions unless the script path is used. This isn't just privacy theater. When sophisticated transactions blend seamlessly with everyday activity, blockchain analysis becomes fundamentally harder. Everyone benefits.

The protocol is standardized as [BIP-327](https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki), implemented in Bitcoin Core, and audited by cryptographers. It works. The math is sound.

But here's the catch: MuSig2 requires two rounds of interactive communication.

## The Problem of Centralized Coordination

MuSig2 isn't a smart contract you deploy and forget. It's an interactive protocol requiring careful orchestration:

**Round 1: Nonce Exchange**
Each participant generates random nonces and commits to them. Everyone must receive everyone else's nonces before proceeding.

**Round 2: Partial Signature Exchange**
Each participant creates a partial signature using their private key, the aggregated nonce, and the transaction data. These partial signatures are combined into the final signature.

**Broadcasting**
Someone has to submit the transaction to the network. Who? What if they refuse? What if they crash?

This creates a coordination problem with several challenging sub-problems:

### Discovery and Session Management

When Alice wants to spend from a 3-of-3 address she shares with Bob and Charlie, how does her wallet tell Bob and Charlie that a signing session has started? The blockchain can't help—the whole point is that nothing happens on-chain until the signature is complete. Traditional approaches:

- **Centralized coordinator server**: Everyone connects to a central service that relays messages. This works until the server is down, censors transactions, gets compromised, or the operator decides to charge fees.
- **Manual coordination**: "Alice emails Bob and Charlie with the transaction hex. Bob replies with his partial signature. Charlie is on vacation and doesn't respond for three days." This doesn't scale.
- **Self-hosted infrastructure**: Everyone runs a server with a public IP and coordinates via direct connections. This excludes mobile wallets, NAT'd users, and anyone unwilling to manage server infrastructure.

### Authentication and Security

How do participants verify that messages actually came from the expected co-signers? MuSig2 signing keys shouldn't be used for authentication—you want to rotate authentication credentials without changing the on-chain address. But separate authentication means more key management.

### Replay Attacks and Nonce Reuse

What prevents Eve from recording Alice's nonce from a previous session and replaying it? Reusing nonces with different messages leaks private keys. The protocol must enforce strict phase transitions: you can't submit a partial signature before nonces are collected, can't reuse nonces across sessions, and can't sign different transactions in the same session.

### Coordinator Failures and Failover

Someone needs to aggregate the partial signatures and broadcast the transaction. The obvious choice is to designate one participant as coordinator. But what happens when they disconnect? Do you wait indefinitely? Do participants manually agree on a new coordinator out-of-band?

### Rate Limiting and DoS Protection

In a peer-to-peer system, what prevents malicious actors from flooding signing sessions with garbage? You need rate limiting, reputation tracking, and the ability to ban misbehaving peers—but without central authority.

The cryptocurrency industry's answer to these problems has mostly been "use a centralized coordinator and hope it stays honest." Enterprises run their own infrastructure. Everyone else trusts third parties or cobbles together brittle coordination mechanisms.

We think there's a better way.

## The Lotusia Solution

Our approach combines three proven distributed systems patterns into a coherent peer-to-peer coordination layer:

### 1. Multi-Layer Discovery

We use libp2p's proven infrastructure with three complementary discovery mechanisms:

**DHT (Distributed Hash Table)**: Session announcements are stored in the Kademlia DHT using the aggregated MuSig2 public key as the identifier. When Alice wants to coordinate a signing session, she publishes an announcement to the DHT. Bob and Charlie query the DHT periodically to discover pending sessions. This provides persistent, decentralized storage without a central server.

**GossipSub**: For instant notification, participants subscribe to a PubSub topic derived from their aggregated public key. When Alice initiates a session, she publishes to the topic and Bob and Charlie receive notifications in 10-100ms—fast enough to feel instantaneous. This gives real-time coordination without polling.

**Direct P2P Connections**: Once participants discover each other, they establish direct encrypted connections for signing. This is more efficient than routing everything through DHT or PubSub, and provides better privacy.

The layered approach handles diverse scenarios: DHT for participants who are temporarily offline, GossipSub for instant coordination when everyone is online, direct connections for bandwidth-sensitive operations.

### 2. Cryptographic Security Throughout

Messages aren't just encrypted—they're cryptographically signed by the sender. Not with MuSig2 signing keys (which must remain cold), but with separate session keys that are signed by the aggregated MuSig2 key during setup. This enables:

- **Key rotation**: Compromise of a session key doesn't compromise the on-chain funds
- **Proof of participation**: Each message is provably from an authorized participant
- **Non-repudiation**: Participants can't later deny sending messages

We layer on additional protections:

- **Rate limiting**: Peers can only send messages at reasonable intervals
- **Peer reputation**: Track behavior over time and deprioritize or ban misbehaving nodes
- **Protocol phase enforcement**: Nonces can't be submitted after partial signatures, transactions can't be broadcast before signatures are complete
- **Optional burn-based identity**: Anchor reputation to blockchain transactions rather than ephemeral peer IDs, enabling long-term reputation that survives key rotation

### 3. Deterministic Coordinator Election

This is the piece that makes failover work elegantly. Instead of manually designating a coordinator, all participants run the same deterministic algorithm:

```typescript
function electCoordinator(publicKeys: Buffer[], sessionId: Buffer): number {
  const hash = sha256(concat(sortLexicographically(publicKeys), sessionId))
  return hash.readUInt32LE(0) % publicKeys.length
}
```

Everyone provides the same inputs (public keys and session ID), everyone runs the same algorithm, everyone arrives at the same coordinator—no voting, no communication, no ambiguity.

When the coordinator crashes or refuses to broadcast? Increment a coordinator epoch and run the algorithm again. The system automatically fails over to the next participant. This continues up to N-1 failures, meaning a 3-of-3 multi-sig only becomes unresponsive if all three participants are offline.

The determinism is critical. In distributed systems, consensus is expensive. But when you can make a decision without coordinating—because everyone independently computes the same answer—you eliminate entire classes of failure modes.

### What This Enables

These patterns combine to support use cases that previously required centralized infrastructure:

**Multi-signature Treasuries**: From 2-of-2 shared accounts to 10-of-10 council treasuries, with automatic coordinator failover ensuring spending ability even during partial outages.

**Payment Channels**: Two-party channels (Alice ↔ Bob) where either party can initiate channel updates, and the channel remains operational even if one party's coordinator software crashes.

**Atomic Swaps**: True peer-to-peer cross-chain swaps where participants coordinate the simultaneous signing of both sides of the swap without a third party.

**Time-Locked Vaults**: Funds requiring multiple signatures to spend before a timeout, single signature after—with the multi-sig coordination happening seamlessly in the background.

**SwapSig Privacy Protocol**: Our CoinJoin-equivalent where multiple parties coordinate to create a single transaction with merged inputs and outputs, breaking on-chain traceability while maintaining individual signature verification.

The infrastructure is general-purpose. Anything requiring interactive multi-party signing can use it.

## Implementation Status and Next Steps

The implementation is complete and working. Over 91 tests validate the protocol implementation, coordinator election, failover scenarios, message authentication, and replay protection. The code has been in active development for weeks and handles edge cases we discovered through extensive testing.

Connection management is properly isolated. Your wallet maintains general P2P connections to the Lotus network, and these are separate from session-specific signing connections. Wallet connection limits won't block multi-sig sessions, and multi-sig activity won't exhaust your general peer slots.

The MuSig2 aggregated public key becomes the Taproot internal key. A 3-of-3 key path spend is 97 bytes and indistinguishable from a single-signature transaction. Complex script trees (for fallback conditions or time locks) remain hidden unless spent via the script path, revealing only the branch that was used.

The implementation lives in [lotus-lib](https://github.com/LotusiaStewardship/lotus-lib), our modern TypeScript SDK for Lotus. Working examples demonstrate:

- Basic 2-of-2 signing with automatic discovery
- Multi-party coordinator election and failover
- Taproot integration with key path and script path spending
- Session management and replay protection

The [technical documentation](https://github.com/LotusiaStewardship/lotus-lib/tree/master/lib/p2p/musig2) covers architecture decisions, security considerations, API usage, and testing procedures. Everything you need to integrate MuSig2 coordination into your application.

We're actively seeking feedback. Install lotus-lib, experiment with the examples, try to break the protocol, report issues. The cryptography is proven, but the engineering is new. Real-world usage will uncover edge cases we haven't considered.

## The Path Forward

MuSig2 solved the mathematical problem of multi-signatures with Schnorr: how do you aggregate keys and signatures securely? The answer is elegant and provably correct. But solving the math doesn't solve the usability problem. Coordinating participants remained hard enough that most implementations defaulted to centralization.

We don't believe that's acceptable. The cryptocurrency ethos is built on decentralization, but we keep centralizing the hard parts because distributed systems are genuinely difficult. The honest answer is: yes, they're difficult, but they're solvable with careful engineering.

This implementation proves that peer-to-peer multi-signature coordination is practical. It requires infrastructure—DHT, GossipSub, cryptographic authentication, deterministic failover—but that infrastructure is general-purpose and reusable. Build it once, use it for treasuries, payment channels, atomic swaps, and privacy protocols.

Technology should enhance human relationships, not replace them. Multi-sig treasuries work best when humans make the governance decisions and protocols handle the technical coordination automatically. Our job as protocol developers is to make the hard parts invisible so people can focus on collaboration rather than infrastructure.

The code works. The tests pass. Now comes the important part: real-world usage. We'll discover edge cases, identify performance bottlenecks, find places where the API is confusing. This is how software matures—slowly, carefully, through genuine use rather than speculation.

Lotus has always been about taking the time to do things properly. Peer-to-peer coordination is complex, but rushing it helps no one. We're building infrastructure for the long term, and that means honest engineering over hype.

The Lotusian Turtle moves slowly, but deliberately, towards victory; one careful step at a time.

---

**Resources:**

- [MuSig2 P2P Documentation](https://github.com/LotusiaStewardship/lotus-lib/tree/master/lib/p2p/musig2) - Complete API reference and examples
- [lotus-lib Repository](https://github.com/LotusiaStewardship/lotus-lib) - Source code and test suite
- [BIP-327 Specification](https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki) - MuSig2 protocol specification
- [Lotus Documentation](https://lotusia.org/docs) - Blockchain and developer guides

**Community:**

- [Discord](https://discord.gg/fZrFa3vf) - Real-time technical discussion
- [Telegram](https://t.me/LotusiaDiscourse) - Community discourse
- [GitHub Issues](https://github.com/LotusiaStewardship/lotus-lib/issues) - Bug reports and feature requests
